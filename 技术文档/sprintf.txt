把整数123 打印成一个字符串保存在s 中：sprintf(s, "%d", 123); //产生"123"sprintf(s, "%d", 123);

可以指定宽度，不足的左边补空格：sprintf(s, "%4d%4d", 123, 4567); //产生：" 1234567"

当然也可以左对齐：sprintf(s, "%-4d%4d", 123, 4567); //产生："123 4567"

也可以按照16 进制打印：sprintf(s, "%8x", 4567); //小写16 进制，宽度占8 个位置，右对齐
		       sprintf(s, "%-8X", 4568); //大写16 进制，宽度占8 个位置，左对齐

这样，一个整数的16 进制字符串就很容易得到，但我们在打印16 进制内容时，通常想要一种左边补0 的等宽格式，那该怎么做呢？很简单，在表示宽度的数字前面加个0 就可以了。
sprintf(s, "%08X", 4567); //产生："000011D7"

上面以”%d”进行的10 进制打印同样也可以使用这种左边补0 的方式。

控制浮点数打印格式
浮点数的打印和格式控制是sprintf 的又一大常用功能，浮点数使用格式符”%f”控制，默认保留小数点后6 位数字，比如：
sprintf(s, "%f", 3.1415926); //产生"3.141593"
但有时我们希望自己控制打印的宽度和小数位数，这时就应该使用：”%m.nf”格式，其中m 表示打印的宽度，n 表示小数点后的位数。比如：
sprintf(s, "%10.3f", 3.1415626); //产生：" 3.142"
sprintf(s, "%-10.3f", 3.1415626); //产生："3.142 "
sprintf(s, "%.3f", 3.1415626); //不指定总宽度，产生："3.142"

字符/Ascii码
我们知道，在C/C++语言中，char 也是一种普通的scalable 类型，除了字长之外，它与short，int，long 这些类型没有本质区别，只不过被大家习惯用来表示字符和字符串而已。（或许当年该把这个类型叫做“byte”，然后现在就可以根据实际情况，使用byte 或short 来把char 通过typedef 定义出来，这样更合适些）于是，使用”%d”或者”%x”打印一个字符，便能得出它的10 进制或16 进制的ASCII 码；反过来，使用”%c”打印一个整数，便可以看到它所对应的ASCII字符。以下程序段把所有可见字符的ASCII 码对照表打印到屏幕上（这里采用printf，注意”#”与”%X”合用时自动为16 进制数增加”0X”前缀）：
for(int i = 32; i < 127; i++) {
printf("[ %c ]: %3d 0x%#04X\n", i, i, i);      //0:将输出的前面补上0，直到占满指定列宽为止
					       //4:列宽
}


连接字符串
char buf[60]={0};
char*who="I";
char*whom="CSDN";
sprintf(buf,"%slove%s.",who,whom);
printf("%s",buf);
//输出结果："IloveCSDN."
或者是：
char a1[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
char a2[] = {'H', 'I', 'J', 'K', 'L', 'M', 'N'};
如果：
sprintf(s, "%s%s", a1, a2); //Don't do that!
十有八九要出问题了。是否可以改成：
sprintf(s, "%7s%7s", a1, a2);
也没好到哪儿去，正确的应该是：
sprintf(s, "%.7s%.7s", a1, a2);//产生："ABCDEFGHIJKLMN"
这可以类比打印浮点数的”%m/nf”，在”%m.ns”中，m 表示占用宽度（字符串长度不足时补空格，超出了则按照实际宽度打印），n 才表示从相应的字符串中最多取用的字符数。通常在打印字符串时m 没什么大用，还是点号后面的n 用的多。自然，也可以前后都只取部分字符：
sprintf(s, "%.6s%.5s", a1, a2);//产生："ABCDEFHIJKL"
在许多时候，我们或许还希望这些格式控制符中用以指定长度信息的数字是动态的，而不是静态指定的，因为许多时候，程序要到运行时才会清楚到底需要取字符数组中的几个字符，这种动态的宽度/精度设置功能在sprintf 的实现中也被考虑到了，sprintf 采用”*”来占用一个本来需要一个指定宽度或精度的常数数字的位置，同样，而实际的宽度或精度就可以和其它被打印的变量一样被提供出来，于是，上面的例子可以变成：
sprintf(s, "%.*s%.*s", 7, a1, 7, a2);
或者：
sprintf(s, "%.*s%.*s", sizeof(a1), a1, sizeof(a2), a2);
实际上，前面介绍的打印字符、整数、浮点数等都可以动态指定那些常量值，比如：
sprintf(s,"%-*d",4,'A');//产生"65"
sprintf(s,"%#0*X",8,128);//产生"0X000080"，"#"产生0X
sprintf(s,"%*.*f",10,2,3.1415926);//产生"3.14"

打印地址信息
有时调试程序时，我们可能想查看某些变量或者成员的地址，由于地址或者指针也不过是个32 位的数，你完全可以使用打印无符号整数的”%u”把他们打印出来：
sprintf(s,"%u",&i);
不过通常人们还是喜欢使用16 进制而不是10 进制来显示一个地址：
sprintf(s,"%08X",&i);
然而，这些都是间接的方法，对于地址打印，sprintf 提供了专门的”%p”：
sprintf(s,"%p",&i);
我觉得它实际上就相当于：
sprintf(s,"%0*x",2*sizeof(void*),&i);


利用sprintf 的返回值
较少有人注意printf/sprintf 函数的返回值，但有时它却是有用的，sprintf 返回了本次函数调用最终打印到字符缓冲区中的字符数目。也就是说每当一次sprinf 调用结束以后，你无须再调用一次strlen 便已经知道了结果字符串的长度。如：
int len=sprintf(s,"%d",i);
对于正整数来说，len 便等于整数i 的10 进制位数。
下面的是个完整的例子，产生10 个[0, 100)之间的随机数，并将他们打印到一个字符数组s 中，
以逗号分隔开。
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int main()
{
srand(time(0));
chars[64];
int offset=0;
for(int i=0;i<10;i++)
{
offset+=sprintf(s+offset,"%d,",rand()%100);
}
s[offset-1]='\n';//将最后一个逗号换成换行符。
printf(s);
return 0;
}